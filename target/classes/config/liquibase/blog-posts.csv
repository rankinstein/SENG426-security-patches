id;title;content;created_date;last_modified_date;type;author_id
1;Hashing Passwords Using MD5 vs. SHA vs. Bcrypt;"<p>Many people have had questions about how to properly store passwords in the database. Most of us have learned that it is a really bad idea to store them in plaintext. </p><p>Instead of storing them in plaintext we do store them with a one-way hash, such as md5, sha or bcrypt. This way even if someone gets a copy of your password database it will become harder to figure out a user’s password. A one way hash in this example is a (seemingly) one-to-one mapping from a string to another string. In theory you can’t run a function on the hashed password to get back the plaintext password. So if someone gets your database then, no problem? </p><p>Well yes and no; a hacker can still try running a huge list of possible passwords and see if they match any of hashes in the database. So the faster a hash function is to calculate the worse it is for security, because the hacker can try more passwords faster and cheaply. </p><p>MD5 and SHA were designed to be really, really fast. So a hacker can run many possible passwords through them in order to check. BCRYPT, which is a variant of the blowfish encryption algorithm, can be made arbitrarily difficult. Put it another way, the number of CPU cycles for MD5 and SHA are very few because they are meant to be fast, bcrypt can be made to require a huge amount of CPU cycles to calculate the result. </p><p>Bcrypt is better because it can be made to take up more CPU cycles. END OF STORY!<p>Or is it… Well in reality <strong>all we are REALLY trying to do is make a trade-off between the number of CPU cycles we are willing to give up in-order to make the users passwords more secure vs. how many CPU cycles the hackers are willing to give up in order to crack the password. </strong></p><p>Sidenote: adding a random salt doesn’t in practice significantly increase the number of CPU cycles, it only makes it so the hackers must recalculate hashes for common passwords. Its never a bad idea to hash, its just not terribly effective either. </p><p>Bcrypt would be an obvious choice if it was more portable, however as of the writing of this post bcrypt is not built into most database servers. MD5 and SHA are available in most servers and languages. Loading an external bcrypt library takes a bit of CPU cycles that could be better used in running the hash function and you have to port all that library. Loading the library doesn’t make the password more secure, only running the algorithm does. So if we want to make things simple just use md5 or SHA iteratively. </p><p>Ultimately, due to lack of portability of bcrypt and high computational cost, I’ve a strong preference toward using MD5 or SHA for password storage. </p>";2017-03-04 01:31:40;2017-03-04 01:31:40;BLOG;6
2;Git workflow for mobile development;"<p>So, we started using gitflow workflow with our server side as well as mobile development. It works out really well with server side code, since there is test coverage and with build automation, feature branches get merged into development branch as soon as they are tested ok. Unlike mobile development, since the changes are live as soon as you wish to (no time to deploy apart from build and testing), you can quickly test if there are any bugs in code you pushed and quickly make changes. So this workflow works out really great for server side development. However we are facing issues with mobile development with this workflow. </p><p>Now there are two major issues that we are facing with this workflow. One is that suppose we merged some feature into development and later figured out that there are lot of bugs in it. Now it can’t be pushed further, whole development cycle is stuck because that code is already merged with development. This is the reason we started forking feature branches from master rather than development as at least individual feature branches will have fully working code. One way is that each feature can be separately distributed to team members to test and only then will be merged to development but it's very cumbersome</p><p>Another problem is since base code with every feature branch is from master branch and it has to be merged with development, there are lot of conflicts. Earlier when we used to fork from development, we used to regularly merge development branch with feature branches so there were no conflicts but can’t do that anymore. So now to fix conflicts, we create another temporary branch from feature branch with which we merge dev code, fix conflicts and put that as pull request which is again little cumbersome. </p><p>Is there a better workflow for mobile development that people have adopted or even some practices that can be followed to solve these problems? </p>";2017-03-04 02:02:16;2017-03-04 02:31:15;BLOG;9

